Para criar um novo projeto em Angular usamos o comando:
    -  ng new appPassaroUrbano --prefix main
    -  Prefix é o nome do seletor pelo qual o componente será invocado dentro do html.
    -  Foi criado uma tag chamada main-root,  <main-root></main-root> para invocar nosso 
    -  componente. 
- Também podemos usar a flag --minimal na criação do projeto se não quisermos que seja 
criado os arquivos de testes.

- Podemos alterar o prefix através do arquivo angular.json.

Instalando o Bootstrap, JQuery e Tether no projeto

- npm install bootstrap@4.5.3 --save
- npm install jquery@3.5.1 --save
- npm install popper.js@1.14.3 --save
- npm install tether@2.0.0 --save

- Após a instalação é necessário referenciar no arquivo angular.json os arquivos de estilo
css e javascript js.

- O Tether é uma biblioteca JavaScript para fazer com que um elemento posicionado 
  absolutamente de forma eficiente fique próximo a outro elemento na página. 
  Por exemplo, você pode desejar que uma dica de ferramenta ou caixa de diálogo 
  seja aberta e permaneça próxima ao item relevante na página.

- Com o Tether Podemos posicionar elementos dentro do DOM (árvore do html) de forma simplificada.

Criando os componentes Topo, Home e Rodape

- Criamos três componentes, topo (header), rodape (footer), home (conteudo principal).
- Para criar os componentes usaremos os seguintes comandos: 

- ng g c topo --skip-tests
- ng g c home --skip-tests
- ng g c rodape --skip-tests

- O nome do seletor pode ser consultado dentro do arquivo ts do proprio componente
ao qual queremos referenciar.
- O nome do seletor é composto pelo nome do seletor principal + nome do componente.
- O nome do seletor principal fica no arquivo angular.json em prefix.

- Comando para rodar o JSON Server:
    - json-server --watch db.json

- A porta default do JSON Server é a 3000.

Criando e alterando o favicon

- O favicon principal da aplicação fica no diretório src/favicon.ico
- Há uma referência para o favicon no arquivo angular.json.

O que são Serviços (Services)?

- Serviços são classes comuns com objetivos bem definidos que visam atender a alguma 
necessidade específica da aplicação.

- A funcão do componente é fazer o databinding com seu respectivo template.
- Podemos criar um serviço para controlar os logs de acesso para podermos saber
quais rotas estão sendo acessadas.
- Podemos usar um serviço para fazer o retorno de uma API de terceiro.
- Quando necessário os serviços podem ser injetados nos componentes que por sua 
vez farão as mudanças visuais em seus templates.
- Um serviço pode ser injetado em três escopos diferentes, em escopo de módulo, por 
exemplo no AppModule é aonde declaramos todos os componentes da aplicação.
- Podemos trabalhar com a mesma instância de um serviço em toda a aplicação de modo 
singleton.
- Um serviço pode ser injetado diretamente no componente e ficar disponível 
apenas no componente em que foi injetado, ou também pode ser declarado no módulo 
principal e ficar disponível em toda a aplicação.
- Um serviço pode ser injetado em outro serviço através da função decoradora @Injectable.

Criando um serviço para exibir ofertas

Injetando o serviço de ofertas no componente Home parte 1

- Instanciar uma classe de serviço dentro do arquivo ts do componente que iremos utilizar
é uma maneira errada de usar um service.
- Primeiro temos que configurar o serviço como sendo um provider.
- Dentro do decorator @Component do arquivo ts do componente atual referenciamos em 
providers o nome da classe que contém o serviço que queremos injetar.
- Segundo temos que criar uma variavel dentro do construtor da classe do componente,
essa variavel será privada e do tipo da classe que contém o service.

- Se declararmos um provider dentro de @NgModule em app.module.ts ele estará disponível
para todos os componentes da aplicação.

Exibindo ofertas com base no serviço OfertasService parte 1

- A idéia é criar uma classe que representa uma oferta e trabalharmos com arrays de ofertas
dentro de nossa aplicação.

App2 - Exibindo ofertas com base no serviço OfertasService parte 2

- Em serviços podemos trabalhar com escopos diferenciados, por exemplo o escopo do módulo 
principal inteiro.

Promises - Entendendo o processamento síncrono e assíncrono

- Promises como o próprio nome sugere são promessas. Na pratica uma promise é um objeto 
usado para processamento assíncrono, esse objeto representa um valor que pode estar 
disponível agora, no futuro ou nunca.

Processamento síncrono e assíncrono

- Processamento síncrono: Aguarda a finalização do processo para seguir para o próximo.
- Processamento assíncrono: Não aguarda a finalização do processo seguindo para o próximo.

Promises na prática parte 1 - Introdução a estratégia de uso

- Algo é síncrono quando o retorno é imediato, por exemplo consultar dados em memória.
- Quando a informação demora certo tempo para ser retornada estamos trabalhando de forma 
assíncrona, nesse caso usamos métodos de promise.

Promises na prática parte 2 (Resolve e then)

- Primeiro criamos uma promessa e depois cumprimos quando houver retorno dos dados.
- Promise é um recurso nativo da linguagem de programação JavaScript.
- Toda promise espera uma função de call-back que é uma ação, a lógica dentro dessa
função pode ser resolvida ou rejeitada.
- Quando há latência (demora) é assíncrono.
- O método then executa ações após a promise ser resolvida ou rejeitada.

Promises na prática parte 3 (Reject e then)

- Existe uma forma de rejeitar e dizer o que tem que ser feito se a promise for rejeitada.

Promises na prática parte 4 (Reject e catch)

- O método catch é muito mais utilizado que o método reject.
- O método catch deixa o código mais organizado e menos verboso para ler.
- É vantajoso usar promise quando ocorrer comunicação de forma assíncrona.

 Promises na prática parte 5 (Processamento assíncrono e encadeamento)

- Podemos encadear vários then um seguido do outro.
- Uma promise pode ser resolvida na sequencia do método em que foi chamada.

Promises na prática parte 5 (Processamento assíncrono e encadeamento)

- Podemos colocar uma promise dentro de outra promise ocorrendo um encadeamento.

Introdução, instalação e testes do pacote json-server

- Foi instalado o json server de forma global para podermos rodar de qualquer 
lugar do nosso sistema.
- Podemos instalar o json-server de forma global com o comando: npm install -g json-server
- Para rodar o servidor usamos o comando: json-server --watch banco-de-dados.json 
- http://localhost:3000/ofertas  -> URI
- Podemos trabalhar com requisições http no json-server como se fosse um banco de dados
real.

Estratégia de consumo de APIs Rest via Angular HTTP

- Temos de um lado nossa aplicação cliente e do outro nossa aplicação servidor.
- Para fazer com que um serviço seja injetado dentro de outro serviço nós precisamos 
utilizar a função decoradora @Injectable.
- Nós vamos pegar o serviço http do Angular 9 e vamos injetar dentro do nosso serviço
OfertasService, dessa forma nosso serviço será capaz de fazer requisições http para 
outras aplicações.
- O http do Angular retorna um Observable mas nesse momento estamos trabalhando com
Promise, nós vamos ajustar o retorno para que nossa aplicação não quebre.
- Vamos entender como usar Promise para consumir API REST.
- Observable é o retorno padrão do serviço http do Angular.
- Vamos converter os retornos de Observables para Promise para entendermos como funciona,
apenas para fins didaticos.
- O protocolo http é baseado em requisição e resposta.

Injetando o serviço HTTP do Angular como dependência de outros serviços

- Dentro do módulo principal que controla nossos componentes que é o app.module.ts, 
precisamos referenciar o HttpClientModule do angular e colocar sua referência no 
arrays de imports.
- O próximo passo é injetar o service do HttpClient dentro do nosso serviço, dentro da 
classe de serviços OfertasService injeta-se somente o HttpClient sem o nome Module.
- Dentro do OfertasService é necessário importar o Injectable, e referenciar @Injectable
no cabeçalho da classe.

Efetuando requisições HTTP para APIs Rest 

Filtrando ofertas

- Podemos aplicar filtros passando parametros direto na uri da requisição para o Json-Server.
- return this.http.get<Oferta[]>('http://localhost:3000/ofertas?destaque=true').toPromise();
- Acima especificamos que queremos somente as ofertas que possuem destaque.

Entendendo a estratégia de implementação do recursos de rotas (Routes)

- Vamos criar mais dois componentes RestauranteComponent e DiversaoComponent.
- Iremos criar um mapa de rotas dentro da nossa aplicação.
- No array de rotas especificamos o path e o componente associado ao path, veja abaixo.
    - { path: 'login', component: LoginComponent }

- O path é o caminho da uri por exemplo /restaurante ou /diversao 
- Conforme a uri é chamada então o componente é renderizado.
- Precisamos criar um mapa de rotas e incorporar dentro da classe AppModule.

Criando os componentes Restaurantes e Diversão

- ng g c Restaurante --skipTests=true
- ng g c Diversao --skipTests=true
- Os componentes são criados dentro da pasta raíz da aplicação.
  - /Users/julio/Desktop/appPassaroUrbano
- Os arquivos do componente são colocados de forma automática dentro da pasta src.
- Dentro da pasta src é criado uma pasta com o mesmo nome do componente em lowercase.

Criando o mapa de rotas

- Vamos criar um mapa de rotas e vamos associar esse mapa ao AppModule que é a classe 
principal da nossa aplicação.
- Dentro do diretório src, /Users/julio/Desktop/appPassaroUrbano/src
- Criamos uma pasta chamada routes, mkdir routes
- Dentro da pasta routes criamos o arquivo app.routes.ts, touch app.routes.ts
- Poderia ser criado um módulo em específico para as rotas.
- Iremos exportar um mapa de rotas.

- Após a criação do arquivo de rotas devemos referenciar no AppModule que é a classe principal.
- Devemos importar o módulo RouterModule em AppModule que é o módulo principal.
- Precisamos passar para o RouterModule o mapa de rotas que criamos.
- É necessário importar a constante de rotas que está dentro do arquivo app.routes.ts 
que criamos, veja abaixo.
    - import { ROUTES } from './../routes/app.routes';

- Por final passamos para o RouterModule a nossa constante que contém um array de rotas.
    - RouterModule.forRoot(ROUTES)

- O forRoot serve para referenciar as rotas globais da aplicação.
- O forChild serve para referenciar as rotas internas dentro do componente.
- Podem haver várias rotas internas dentro de um componente.
- Temos que dizer ao angular em qual região um componente baseado em determinado path
deve ser colocado, para fazer isso usamos a tag <router-outlet></router-outlet>.

Estabelecendo a navegação entre rotas

- Podemos navegar entre componentes através da diretiva routerLink, veja abaixo:
    - <a class="nav-link" routerLinkActive="active" [routerLink]="['/diversao']">Diversão</a>

- Podemos descobrir qual é a rota que está ativa e a partir disso tomar uma ação.

Alterando a classe do elemento associado a rota ativa

- Existe uma diretiva chamada routerLinkActive que serve para aplicar classe css ao elemento
html caso o elemento corresponda a rota ativa.
-   <a class="nav-link" routerLinkActive="active" [routerLink]="['/diversao']">Diversão</a>
- Acima active se refere a uma classe do bootstrap que dá estilo ao link que está sendo exibido.

Recuperando ofertas do tipo Restaurante (HTTP Resquest / API Rest / Promise)

- Nossas ofertas serão mostradas de forma dinâmica com base em requisições http que será 
feita para a api rest.

Recuperando ofertas do tipo Diversao (HTTP Resquest / API Rest / Promise)

Criando e navegando para a página Oferta

- Iremos criar um componente chamado oferta sendo que o objetivo desse componente será mostrar
a página onde poderemos ver os detalhes das ofertas, cada uma das ofertas permite acesso 
a uma página contendo seus detalhes.
- Criamos o componente com o comando: ng g c oferta --skipTests=true

Passando parâmetros na navegação

- Vamos aprender a passar parametros durante a navegação entre as rotas da aplicação.
- A passagem de parametros é um recurso muito importante pois os parametros servem para
configurar as tratativas de back-end.
- Por exemplo no nosso componente oferta nós precisamos receber um parametro que corresponda 
ao id da oferta clicada para que com base nesse parametro a gente possa configurar a 
consulta que vamos fazer na nossa API de back-end.
- Como configuro o path para que ele seja capaz de identificar e receber parametros?
- Primeiro temos que indicar para o path como ele deve receber esses parametros.
- É necessário criar uma nova rota com parametro dentro do path, veja abaixo:
    -     { path: 'oferta', component: OfertaComponent },
    -     { path: 'oferta/:id', component: OfertaComponent }
- Então teremos duas rotas para o mesmo componente, uma que recebe parametro e outra que não.
- No momento que o path for acessado com a passagem do parametro nós vamos poder recuperar 
esse parametro dentro do componente que foi chamado, o parametro possuí um aliás, nesse 
caso ele se chama id.
- Todos os paths correspodem a uma assinatura única.
- Abaixo temos ume exemplo de passagem de parametro através do routerLink.
    - <a [routerLink]="['/oferta', oferta.id]" class="btn btn-outline-primary">Ver oferta</a>
- Podemos atribuir a diretiva routerLink tanto em botões, links, entre outros elementos do html.
    - <button class="btn btn-outline-success"[routerLink]="['/oferta', oferta.id]">Ver oferta</button>

Recuperando parâmetros da rota (Snapshot vs Subscribe)

- Snapshot: Tira uma "foto" da rota permitindo acessar seus parametros.
- Subscribe: Fica "escutando" alterações na rota. Quando uma alteração é "escutada" 
podemos reagir a mudança (reactive programming).
- O Snapshot será utilizado na grande maioria das vezes, porque o que faremos é sair 
de uma rota e entrar em outra.
- Dentro de uma mesma página se houver um componente que é alterado com base em outro 
componente então nós podemos utilizar o Subscribe para esse fim.
- Um exemplo de uso do Subscribe é quando há uma rota fixa e dentro dessa rota houver 
dois componentes e seja necessário comunicação entre esses componentes.

Recuperando parâmetros da rota com Snapshot

- OfertaComponent receberá como parametro o id da oferta através de Snapshot.
    - const id = this.route.snapshot.paramMap.get('id');
- Precisamos colocar uma variavel do tipo ActivatedRoute dentro do construtor do componente
que vai receber o parametro.
- Podemos receber mais de um parametro na rota, podemos receber um array de parametros.

Recuperando parâmetros da rota com Subscribe

- Um Subscribe pode retornar string ou null.
- Vamos declarar uma variavel chamada id_oferta.
    -  id_oferta: string | null = null;
- Abaixo capturamos o valor do parametro id vindo na uri através do subscribe.
    - this.route.paramMap.subscribe(parametro => this.id_oferta = parametro.get('id'));

Recuperando a oferta selecionada (HTTP Resquest / API Rest / Promise

- Vamos recuperar a oferta através do id encaminhado na rota.

Processamento assíncrono e a construção do template

- Pode ocorrer do angular renderizar a página mais rápido que ocorre a requisição
para o banco de dados, então pode ocorrer erro de undefined ou null, por isso é 
necessário fazer validações quando estamos trabalhando com requisições assíncronas.
- Veja abaixo um exemplo de validação.
    - <div class="img_capa" *ngIf="oferta.imagens[0] !== undefined && oferta.imagens[0] !== null">

- No exemplo acima todo conteúdo da div só será renderizado se a condição do if for verdadeira.
- Nossa aplicação deve ter inteligência para acessar os dados somente quando eles estiverem
disponíveis.

Ajustando a url de acesso a API

- Para evitar repetição de código dentro de nossa aplicação, por exemplo o endereço da 
URI de acesso aos dados da nossa api rest.
- Podemos criar um atributo na classe de serviço OfertasService como privado e atribuir o 
endereço da uri de ofertas para ele.
- Veja abaixo.
    - private uri_api_ofertas = 'http://localhost:3000/ofertas';
- Podem haver vários serviços separados em módulos diferentes.
- O mais indicado é criar um arquivo com todas as URI`s do nosso projeto para facilitar
manutenções posteriores.
- O mais certo é isolar o path das URI`s em um arquivo e exportar todas as constantes que
estão nesse arquivo, cada arquivo representa um módulo que pode ser importado.

Criando as tabs "Como usar" e "Onde fica"?

- Vamos implementar um sistema de navegação interno, nós já aprendemos a criar um sistema 
de navegação forRoot() para a aplicação como um todo, agora vamos descobrir como podemos 
implementar um sistema de navegação forChild() dentro de um componente.
- Em geral esse tipo de recurso é utilizado para facilitar a interação entre componentes
parents.
- É necessário estruturar o layout.
- O componente Oferta terá um router-outlet filho.

Criando os componentes ComoUsarComponent e OndeFicaComponent

- Os dois componentes que iremos criar fazem parte do componente oferta, pois eles 
serão renderizados sob demanda dentro do componente oferta.
- Os dois componentes serão criados dentro do diretório do componente oferta, no meu 
caso eu vou criar fora, criarei em /src/app
- Os dois componentes serão criados com o comando abaixo:
    -  ng g c ComoUsar --skipTests=true
    -  ng g c OndeFica --skipTests=true

Configurando rotas filhas

- Como montar um sistema de roteamento interno?
- Vamos criar rotas filhas dentro do componente Oferta, para isso é necessário ir 
no arquivo de rotas onde contém o array de rotas.
- Dentro do path da rota principal vamos adicionar a propriedade children, veja abaixo:

-       path: 'oferta/:id', component: OfertaComponent,
        children: [{ path: 'como-usar', component: ComoUsarComponent },
        { path: 'onde-fica', component: OndeFicaComponent }]

- É necessário referenciar router-outlet aonde queremos exibir o conteúdo que queremos
dentro do template html do componente Oferta.
- Quando efetuamos o acesso direto para a rota Oferta o router-outlet não sabe qual componente
irá renderizar, se é o ComoUsarComponent ou o OndeFicaComponent.
- Para resolver isso precisamos indicar que se nenhum parametro for passado deve-se ir para 
a rota raíz que no caso será o primeiro componente a ser exibido, no nosso caso o ComoUsarComponent.
- O próximo passo é implementar a navegação entre os componentes.

Navegando entre as rotas filhas como-usar e onde-fica

- Vamos navegar entre os componentes através dos links contidos nas tabs.
- <a class="nav-link active" routerLink="como-usar" data-toggle="tab" role="tab" aria-selected="true">Como usar</a>

Recuperando parâmetros da rota parent (pai) nas rotas filhas

- Teremos que pegar o id da oferta que está na rota forRoot() e passar para a rota
forChild() para que os componentes OndeFicaComponent e como ComoUsarComponent façam 
buscas na api rest e rendezirem as informações no seu respectivo template (arquivo html).
- Para fazer busca nos parametros da rota pai (parent) usamos o seguinte comando:
    - this.route.parent?.paramMap.subscribe(param => this.id_oferta = param.get('id'));
- route é uma instância de ActivatedRoute declarado dentro do construtor do componente filho.

Recuperando dados "Como usar" via HTTP Request

- Para recuperar os dados é o processo normal através do service de ofertas.

 Introdução a Reactive Programming

 - Consiste em um paradigma de programação voltado a fluxos.
 - O switchMap serve para que, por exemplo, se você fizer 5 requisições, ele irá processar 
apenas a última delas, que é a que realmente importa para nós, construiremos nosso objeto
uma vez e substituiremos o array somente uma vez. Resumindo: usando switchMap todos os 
requests anteriores serão ignorados se um novo evento chegar.
- Reduzir o número de chamadas de API para seu servidor usando debounceTime.

Introdução a Observables

- Observable é o recurso utilizado pelo Angular para atender de modo efetivo aos pilares
da programação reativa.
- Observable é um recurso da lib rxjs que está disponível para diversas linguagens inclusive
JavaScript.
- Observables trabalham em cima de tarefas assíncronas de forma parecida com as promises.
- Observable é capaz de lidar com: instrução, erro e conclusão.

Observables na prática parte 2 - Interval operator

- interval é uma propriedade da classe Subscribe que define o que ocorrerá em 
um intervalo de tempo baseado em milisegundos.
- Podemos enviar requisições para um servidor a cada 2 segundos por exemplo.

Observables na prática parte 4 - Finalizando stream com error() e ou complete()

- Podemos parar um observable com o método error.
- Podemos concluir uma operação com o método complete.
- Um subscribe possuí três parametros.

Observables na prática parte 5 - Memory leak e Unsubscribe

- Memory leak significa vazamento de memória.
- Para evitar memory leak uma alternativa é utilizar a interface OnDestroy e implementar
o método ngOnDestroy().
- Dentro do método ngOnDestroy() devemos efetuar o unsubscribe nos observables.

Incluindo o campo de pesquisa de ofertas

- Criaremos um campo para filtrar as ofertas de forma dinamica, fazendo com que ao 
digitar caracteres o filtro seja executado.
- Para o event binding [(ngModel)]="user.nome" funcionar deve ser importado o módulo 
FormsModule em app.module.ts que é a classe principal AppModule.
- Podemos criar variáveis locais dentro de tags do html usando cerquilha, por exemplo:
    -  <input type="text" class="form-control mt-3" placeholder="Pesquise por ofertas" #termoPesquisa
            (keyup)="pesquisa(termoPesquisa.value)" />

- No caso acima a propriedade value está no contexto da variavel local dentro do input, 
ela esta pegando o valor digitado dentro do input e passando como argumento para a função
pesquisa.
- A forma mais apropriada é usar event binding ao invés do mostrado acima.

Criando um Observable para pesquisa de ofertas em OfertasService

- Após sabermos como que se recupera o termo que desejamos buscar agora vamos criar
o serviço para buscar a oferta no banco de dados.
- Vamos buscar as ofertas no banco de dados utilizando o padrão observable.
- Como usar o like no Json-Server?
- Para usarmos o like no Json-Server colocamos o _like concatenado no 
nome do atributo que está no banco de dados na uri de pesquisa, veja abaixo:
    - public getPesquisaOfertasPorNome(termo: string): Observable<Oferta[]> {
        return this.http.get<Oferta[]>(`${this.uri_api_ofertas}?descricao_oferta_like=${termo}`);
    }

Lógica da pesquisa de ofertas parte 1 - Executando pesquisaOfertas

- Uma api pode ter diferentes formas de lidar com requisições http.

Lógica da pesquisa de ofertas parte 2 - Erro e Retry Operator

- O retry pode ser utilizado em conjunto com o delay para fazer tentativas de
acesso a requisições http de modo sequencial, ou com intervalo de tempo.

- O map pode ser usado como um mecanismo de transformação de dados.
- Handles são formas de lidar com os eventos.

Lógica da pesquisa de ofertas parte 4 - Subject e switchMap

- Programação Reativa é um paradigma, algumas soluções não podem ser interpretadas como
soluções orientada a objetos ou funcionais.
- Podemos disparar requisições a cada 2 segundos em um campo de pesquisa para dar 
tempo de o usuário digitar o termo de pesquisa.
- Vamos criar um Observable capaz de gerenciar os eventos que estão sendo produzidos 
dentro de nossa aplicação.

Subject: 
    - Funciona como um proxy atuando tanto como observável quanto observador.

switchMap:
    - Permite recuperar parametros que são enviados ao subject e executar um observable.
    - O switchMap irá sequenciar a execução dos observables fazendo com que os observables
    anteriores sejam cancelados, ou seja, ele faz um unsubscribe do observable de forma 
    automática mantendo apenas o observable mais recente.

Lógica da pesquisa de ofertas parte 5 - DebounceTime

- Podemos implementar lógicas para disparar os observables.
- Vamos aplicar um determinado tempo para o observable de pesquisa ser executado.
- Um único evento será disparado após determinado tempo.
- Com isso a aplicação consumirá menos recursos de processamento.

Lógica da pesquisa de ofertas parte 6 - Evitando pesquisas por strings vazias
    
- Basta fazer um if para verificar se o termo de pesquisa esta preenchido.

Lógica da pesquisa de ofertas parte 7 - DistinctUntilChanged

- Serve para verificar se a pesquisa atual é igual a pesquisa anterior.
- Se a pesquisa atual for igual a anterior a execução do método switchMap será 
desconsiderada, ou seja, não ocorrerá uma nova pesquisa no banco de dados.

Lógica da pesquisa de ofertas parte 8 - Catch

- O catch serve para capturar a exceção ocorrida e a partir dele pode ser feito o 
tratamento da exceção ocorrida. 

Lógica da pesquisa de ofertas parte 9 - Trabalhando o template

- Podemos fazer várias validações no template como por exemplo verificar se o campo 
está preenchido antes de mostrar um resultado.

O que são Pipes?

- São mecanismos de transformação de dados utilizados nos templates para produzir uma 
representação customizada da informação a ser exibida.
- Podemos usar pipes para informar ao angular como determinado dado pode ser modificado e 
consequentemente exibido.
- Podemos usar | uppercase para todos os caracteres serem exibidos em caixa alta.
- Com pipes podemos tranformar o output de dados em nossas views.
- Possibilita deixar a informação para o usuário final mais amigavel.
- Podemos criar nossos próprios pipes "|".

Usando os pipes json, uppercase e lowercase

- Veja abaixo um exemplo:
    <li class="list-group-item" *ngFor="let oferta of ofertaDetails">{{oferta.titulo | uppercase}}</li>

Ajustando a formatação de moedas para o padrão Brasileiro (internacionalização)

- O primeiro passo é instalar o intl para prover nosso serviço de formatação.
- npm install --save intl@1.2.5
- É necessário fazer o import no arquivo polyfills.ts dos seguintes módulos:
    
    import 'intl';
    import 'intl/locale-data/jsonp/pt-BR';

- O próximo passo é configurar no módulo principal da aplicação.
- Como nossa aplicação tem um único módulo então fica mais fácil, vamos abrir o arquivo
app.module.ts e adicionar as configurações.
    
    import { registerLocaleData } from '@angular/common';
    import localePt from '@angular/common/locales/pt';

    registerLocaleData(localePt);

- Configurar dentro do array de providers:

    {
      provide: LOCALE_ID,
      useValue: 'pt-BR'
    }

Criando um pipe customizado parte 1 - Criando e utilizando

- Cada pipe implementa uma lógica interna para poder trabalhar determinada informação.
- Existe uma série de pipes que já estão pré-definidos no Angular.
- Podemos desenvolver pipes "|" para atender as nossas necessidades.
- Podemos usar um pipe para truncar uma string para não estourar uma caixa de layout 
por exemplo.
- Podemos criar um pipe e usar sempre que necessário.

    - mkdir util
    - cd util
    - touch descricao-reduzida.pipe.ts

- Devemos implementar a interface PipeTransform

    @Pipe({ name: 'descricaoReduzida', pure: true })
    export class DecricaoReduzida implements PipeTransform 

- Após a criação do pipe devemos declará-lo no módulo.
    import { DescricaoReduzida } from './util/descricao-reduzida.pipe';

Criando um pipe customizado parte 2 - Configurando parâmetros

- Podemos encaminhar parametros para o pipe para que ele possa fazer a saída dos dados.
    <li class="list-group-item" *ngFor="let oferta of ofertaDetails">{{oferta.titulo | uppercase |
        descricaoReduzida:3}}</li>

- Parametros podem ser encaminhados colocando | nomeDoPipe:Parametro 
- Podemos passar mais de um parametro dessa forma: | nomeDoPipe:Param1:Param2:Param3

Encadeando múltiplos pipes

- Podemos chamar um pipe na sequencia do outro, o segundo pipe irá pegar o resultado da saída
de dados do primeiro.

    - {{ oferta.titulo | uppercase | descricaoReduzida:8 }}

Pipe async (Inscrição em Observables e Promises)

- O pipe async serve para fazer com que dados do template se inscrevam diretamente em observables
ou promises.
- Qualquer informação a ser exibida no template proveniente de um processamento assíncrono pode 
ser diretamente conectado com o retorno do processamento do pipe.
- O | async serve para fazer subscribe em observable e promise a partir do template.
   
    - public oferta_array: Observable<Oferta[]> = new Observable<Oferta[]>();

    -  <li class="list-group-item" *ngFor="let oferta of oferta_array | async">{{oferta.titulo | uppercase |
             descricaoReduzida:8}}</li>
        
- O pipe async consegue extrair os dados do array de ofertas de dentro do observable e renderizar
as propriedades de oferta na tela.
- Podemos usar o ngFor em conjunto com uma resposta http da seguinte forma:

    <ul class="list-group" style="position: absolute; width: 95%;" *ngIf="termoPesquisa.trim() !== '' ">
            <li class="list-group-item" *ngFor="let oferta of ofertaResponseHttp.body">{{oferta.titulo |
                    uppercase |
                    descricaoReduzida:8}}</li>
    </ul>

 Navegando para oferta a partir do campo de pesquisa

 - Vamos aprender como acessar os dados das ofertas retornadas na pesquisa.
 
 Atualizando oferta no processo de mudança de rota

 - Os componentes devem ser atualizados no momento em que ocorre o snapshot na rota.
 - Quando for detectado alguma mudança de rota o componente da oferta deve ser carregado.
 - A chamada deve ser feita dentro do corpo do subscribe que está recuperando o id.
 
 Atualizando "como usar" e "onde fica" no processo de mudança de rota

 - Todo o processo deve ser feito dentro do corpo do subscribe que está capturando 
 o id da rota como parametro, tanto para como-usar quanto para onde-fica.

 [Fix Bootstrap] - Ajustando a versão de alpha para beta

 - xxx...